#pragma once
#include<stdexcept>
using namespace std;
// DO NOT EDIT THIS FILE IN ANY WAY

// Node class for Linked List
class Ex4Node
{
public:
	int data;
	Ex4Node* previous;
	Ex4Node* next;
	Ex4Node(int val, Ex4Node* prev, Ex4Node* nxt) : data(val), previous(prev), next(nxt) {};
	Ex4Node(int val) : data(val), previous(nullptr), next(nullptr) {};
};

// Implemented with a doubly linked list, looks something like this
// Note that front and back are both nodes and contain data
// nullptr<-prev:front:nxt-><-prev:nd:nxt->...<-prev:nd:nxt->-<prev:back:nxt->nullptr
class Deque
{
public:
	// Constructors, destructor and overloaded op=
	Deque();
	Deque(const Deque & dq);
	Deque & operator=(const Deque & dq); 
	~Deque();

	// Mutators
	// PARAM: val = value to be inserted
	// POST: inserts val at the front of the deque
	void insert_front(int val);
	// PARAM: val = value to be inserted
	// POST: inserts val at the back of the deque
	void insert_back(int val);

	// POST: removes node at the front of the deque and returns its data
	int remove_front();
	// POST: removes node at the back of the deque and returns its data
	int remove_back();

	// POST: returns the number values stored in the deque
	int size() const;
	// POST: returns T iff deque is empty
	bool empty() const;

	// POST: Prints contents of deque from front to back
	void printForwards() const;
	// POST: Prints contents of deque from back to front
	void printBackwards() const;

private:
	int n;
	Ex4Node* front;
	Ex4Node* back;

	// PARAM: dq = deque to be copied
	// POST: calling object is made a copy of dq
	void copyDeque(const Deque & dq);

	// PRE: original and copy are appropriate pointers
	// PARAM: original = pointer to a node in a deque being copied
	//        copy = pointer to a node in the calling object
	// POST: calling object is made a copy of dq
	void copyNode(Ex4Node* original, Ex4Node* copy);

	// Deallocates all dynamic memory associated with calling object
	void removeAll();
};



